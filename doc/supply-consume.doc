Hierarchical node supply & consume
---

Take some node N. Its immediate children (subnodes) can be:

  - explicitly supplied by some reactive procedures
  - created just for the sake of individual consumption, i.e. unsupplied
  - anything of the 2 but for some nested descendants.

Consumption:

  - node-level: whether this particular node exists
  - plane-level: I want to know about all of this planes nodes.

Supplying is different, it's not 1-vs-many as with consumption. Nodes are always supplied
individually, i.e. there's no plane-level supply. But we have lazy supply, or inference
rules, that come into action when someone is explicitly consuming what they say they can
supply.

Fact 1: if we have an inference rule with the head "D.one(*).two(*).three(*)" and "D.one
(1).two(*)" is consumed, then we have to run this rule, because it can
supply "D.one.two" -- what we need. Even though it supplies more than we require
(deeper structure).


```js
rv.infer(
  D.country(v.Cr).city(v.Cy),
  D.city(v.Cy).country(v.Cr)
);

```

```js

D.product(Product).onDate(Date).soldAtSale(Sale)

```


Fact 2: even if we only have node-level consumers, we still need to run all the inference
rules that claim to supply into this plane. Because any of them may supply the subnode
that the consumer is interested in.

So, any consumption at all activates all the plane's lazy suppliers.


Do we need deep plane-level consumers?
---

For example, at a concrete node C: A -> B -> C, we consume the suffix ".D.E.F". Meaning
that we need all D's, E's and F's.

Do we need to have the explicit prefix part and suffix part in a rule?

```js
rv.infer(
  D.product(v`Product`).onDate(v`Date`),
  _.soldAtSale(v`Sale`, rv.do(
    v`Product`.event(v`Event`),
    v`Event`.sale(v`Sale`),
    v`Date` < v`Sale`.saleEnd,
    v`Date` > v`Sale`.saleStart
  ))
);
```

So there can be 3 cases w.r.t. deep supplying:

  1. Don't supply intermediate nodes, i.e. supply only starting from some nesting.
  2. Supply some chain of intermediate nodes, like with `.D().E().F()` above.

Only the leaf node is actually supplied. All the intermediate nodes are supplied
indirectly. When at any intermediate level there's any consumption, we run the whole
rule (at the deepest level, where is the actual body attached).

  3. Supply separately at various levels. This is in fact multiple inference rules merged
  into one. But they still share the variable namespace.



Preventing cycles
---

We may have cycles. Node A gives life to node B through some rule, then the node B
supplies back A increasing its supply count (through the same or another rule) to A.
Generally, these vicious circles may be more than 2 links long. How do we deal with this
sort of problem?

For each agent, there's a set of nodes that it generates through primary support
(transitive closure). Those that it immediately generates, then for each of them all the
agents that depend on it, then what they immediately generate, etc. Ultimately, the point
is that the initial agent is necessary (among other agents) to generate all of these
nodes: without it, they wouldn't have existed.

The idea is to check whether the accessed node belong to the set of procreated nodes of an
agent. If yes, then we consider the node as non-existing? But another agent may be
supporting this node as a secondary supporter which can become a primary one.


No, this is an inferior approach. This is a subset of the normal GC algorithm.


Why I don't like the GC? Because we go upwards not linearly but in N directions
simultaneously. So this is kind of a multiple-descending tree, where Agents in fact have
multiple simultaneous parents (nodes), and we have to ascend from an agent into all of
its dependencies at once, by either BFS or DFS. We ultimately look for whether a
particular agent has a particular node as its dependency.
